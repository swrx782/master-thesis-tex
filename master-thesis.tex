% 参考サイト: http://www.is.nagoya-u.ac.jp/dep-ss/phil/kukita/others/How_to_use_TeX.pdf










\documentclass[titlepage]{jsarticle}










\usepackage{amsmath}

\usepackage{amsthm}
\newtheorem{thm}{定理}
\newtheorem{definition}[thm]{定義}
\newtheorem{example}[thm]{例}







\title{MiniSatと遺伝アルゴリズムを組み合わせた短い証明の作成}
\author{和田 翔太}
\date{\today}










\begin{document}










\maketitle










\section{概要}










\section{導入}










\section{準備}





\subsection{SAT}



SATとは命題論理式の充足可能性を判定する問題でSatisfiability Problemの頭3文字を取ってSATと呼ばれる。
これは与えられた命題論理式を真にするような各変数への割り当てが存在するかどうか(充足可能かどうか)判定するという問題である。
命題論理式を真にするような各変数への割り当てが存在する場合は充足可能(SAT), 各変数にどのような割り当てをしても全体が真にならない場合は充足不能(UNSAT)となる。
通常SATである場合はその解(各変数への割り当て)を出力する。



\subsubsection{定義}

真を表す$\top$または偽を表す$\bot$を値にとる変数
\[
x_1, x_2, ...
\]
を命題変数と呼ぶ。命題変数$x_1$は1変数からなる論理式となる。
命題論理式はこれらの命題変数を組み合わせることで表現される。

次に命題変数$x_1, x_2, ...$に対して操作を表す記号$\lor, \land, \neg$を導入する。
これらの記号は論理演算子と呼ばれ、それぞれ論理和、論理積、否定と呼ばれる。

命題変数$x_i$と$x_j$の論理和を$x_i \lor x_j$で表す。$x_i$と$x_j$がどちらも偽である場合に偽になり、それ以外の場合は真となる。
また、命題変数$x_i$と$x_j$の論理積$x_i \land x_j$で表す。$x_i$と$x_j$がどちらも真である場合に真になり、それ以外の場合は偽となる。
\[
	x_i \lor x_j = 
	\begin{cases}
		\bot & (x_i=x_j=\bot{の場合}) \\
		\top & ({それ以外の場合}) \\
	\end{cases}
	, 
	x_i \land x_j = 
	\begin{cases}
		\top & (x_i=x_j=\top{の場合}) \\
		\bot & ({それ以外の場合}) \\
	\end{cases}
\]

命題変数$x$に対してその否定を$\neg x_i$で表す。$x_i$が真である場合に$\neg x_i$は偽になり、$x_i$が偽である場合に$\neg x_i$は真となる。
\[
	\neg x_i =
	\begin{cases}
		\bot & (x_i=\top{の場合}) \\
		\top & (x_i=\bot{の場合}) \\
	\end{cases}
\]

上記の論理演算子を命題変数と組み合わせたものは論理式となる。
例えば命題変数$x_i, x_j$に対して$\neg x_i$は1変数からなる論理式に、
$x_i \lor x_j, x_i \land x_j$はそれぞれ2変数からなる論理式になる。

論理式$X_i, X_j$に対しても命題変数と同様に論理式の論理和$X_i \lor X_j$, 論理積$X_i \land X_j$, 否定$\neg X_i$を定義することができる。

上記の3つの論理演算子とは他の演算子として排他的論理和$\oplus$, 含意$\to$, 同値$\leftrightarrow$があるが、
今回のSATの問題を表現する際に用いないので省略する。
実際には排他的論理和$\oplus$, 含意$\to$, 同値$\leftrightarrow$は全て論理和$\lor$, 論理積$\land$, 否定$\neg$を用いて表現できるため、
6つ論理演算子で表現できる論理式は全て論理和$\lor$, 論理積$\land$, 否定$\neg$を用いて表現できる。

SATの問題は通常、連言標準形(conjunctive normal form; CNF)と呼ばれる特定の形式の論理式で表現される。
命題変数$x_i$に対して命題変数$x_i$または命題変数の否定$\neg x_i$をリテラルと呼ぶ。
リテラル$l_1, l_2, ...l_n$に対してそれらを論理和$\lor$でつないだ論理式
\[
	l_1 \lor l_2 \lor ... l_n
\]
を節と呼ぶ。
SATの問題(CNF式)$F$はこの節$C_1, C_2, ...C_m$を論理積$\land$で繋いだ論理式
\[
	C_1 \land C_2 \land ... \land C_m = (l_{11} \lor l_{12} \lor ... l_{1n_1}) \land (l_{21} \lor l_{22} \lor ... l_{2n_2}) \land ... \land (l_{m1} \lor l_{m2} \lor ... l_{mn_m})
\]
で表現される。
例えば論理式$(x_1 \lor x_2) \land (\neg x_3 \lor x_4)$はCNF式であるが、
論理式$(x_1 \land x_2) \lor (\neg x_3 \lor x_4)$はCNF式ではない。
また節をリテラルの集合で表し、CNF式を節の集合で表すことがある。
先ほどの例のCNF式$(x_1 \lor x_2) \land (\neg x_3 \lor x_4)$は$\{\{x_1, x_2\}, \{\neg x_3, x_4\}\}$といった集合で表現される。

最後に充足可能、充足不能について定義する。
命題変数についてその割当(未割当も含めた)を写像
\[
	\nu: X \to \{\top, \bot, u\} (X{は命題変数の集合とし、}u{は未割当であることを表す})
\]
で定義する。
この写像$\nu$をリテラル$l$, 節$C=\{l_1, l_2, ..., l_n\}$, CNF式$F=\{C_1, C_2, ..., C_m\}$についても割当ができるように以下のように拡張する。
\begin{align*}
	\nu(l) & = 
	\begin{cases}
		\nu(x)     & (l= x{の場合}) \\
		\neg\nu(x) & (l=\neg x{の場合}) \\
	\end{cases}
	({ただし}\neg u = u{とする}) \\
	\nu(C) & = \nu(l_1) \lor  \nu(l_2) \lor  ... \lor  \nu(l_n) \\
	\nu(F) & = \nu(C_1) \land \nu(C_2) \land ... \land \nu(C_m)
\end{align*}

CNF式$F$に対して充足可能(SAT)とはある割当$\nu$が存在して
\[
	\nu(F) = \top
\]
となることをいう。
そしてCNF式$F$に対して充足不能(UNSAT)とは任意の割当$\nu$に対して
\[
	\nu(F) = \bot
\]
となることをいう。



\begin{example}
	$ (x_1 \lor x_2) \land (x_1 \lor \neg x_2) \land (\neg x_1 \lor \neg x_2) $はSATである。
	これを充足する割当$\nu$の例としては$x_1=\top$, $x_2=\bot$が挙げられる。
\end{example}

\begin{example}
	$(x_1 \lor x_2) \land (\neg x_1 \lor x_2) \land (x_1 \lor \neg x_2) \land (\neg x_1 \lor \neg x_2)$はUNSATである。
	変数$x_1,x_2$に真偽値を割当てる方法は合計で$4$つあるが、そのいずれもこの論理式を充足しないことが確認できる。
\end{example}




\subsection{SAT solver}
充足可能性問題を解くソルバーのことをSAT solverと呼ぶ。
充足可能性問題はNP完全に属し、解くのに時間がかかる。% 時間がかかることを説明したい
一番愚直な解き方として、各変数に$\top$と$\bot$を代入して全体が真になるかどうかを判断する方法がある。
しかしこの場合最悪$2^n$回確認をしなければならない。
そのため、速く解くために様々な手法が用いられる。 



\subsubsection{DPLLアルゴリズム}
DPLL(Davis-Putnam-Logemann-Loveland)アルゴリズムとは単位伝搬(Unit propagation)を用いたアルゴリズムのことである。
CNF式の命題論理式は各節が論理積で繋がった形をしているため、全体が真となるためにはその各節が真とならなければならない。
もし仮にある節において、1つのリテラルのみが未定義でその他のリテラルが偽になる場合($x \land \bot \land \bot ...$)、その節が真になるためには未定義のリテラルが真にならなければならない。
このようにして未定義のリテラルが真になるように割り当てを行うことを単位伝搬という(またそのような節を単位節と呼ぶ)。
DPLLアルゴリズムは以下のような流れで問題を解いていく
\begin{enumerate}
	\item 単位節がある場合、それを充足するように変数に割り当てを行う(単位伝搬)
	\item 単位節がない場合、適当な変数を選択し真または偽を割り当てていく
	\begin{itemize}
		\item 割り当てによって単位節ができた場合、単位伝搬を行う
		\item 矛盾が発生した場合、最後に選択していた変数の真偽値を反転(すでに反転していた場合はその1つ前の変数を反転)させる
	\end{itemize}
	\item 全体が真になった場合はSAT(とその割り当て)を、すべての割り当てにおいて全体が偽になった場合はUNSATを返す
\end{enumerate}



\subsubsection{変数選択における重み}
DPLLアルゴリズムにおいて変数選択をする際に未割当の変数が複数ある場合、どの変数を選択すべきかという問題がある。
一番シンプルな方法としてランダムに選ぶ方法もあるが、実際にはどのようにして変数を選択するかが決まっている。
多くのソルバーにおいてはあるルールに従って各変数に重み(スコア)をつけることで変数選択をする時に重みが一番大きい変数を選択するようになっている。
後述するソルバーの1つであるminisatにおいては、矛盾が発生した際にその矛盾を引き起こすのに関わった変数(その時に作った学習節に含まれる変数)のスコアが上がるように計算することで、
直近の矛盾に関わった変数ほどスコアが高くなっている。
変数選択の際には一番重みが大きい変数を選択している。



\subsubsection{矛盾からの節学習(CDCL solver)}
DPLLアルゴリズムに基づいた高速SAT solverの大きな特徴であり、
これを用いたsolverはしばしばCDCL(conflict-driven clause learning) solverと呼ばれる。
節学習の流れとして、まず、DPLLアルゴリズムにおいて矛盾が起きた際にどの変数への割り当てが矛盾を引き起こしたのかなどの原因を調べる。
そして今後変数割当や単位伝搬を進めていく中でさきほどの矛盾を引き起こした変数らへの割当を防ぐために
新しい節を学習節として新しく節を加える。
これを続けていくことでDPLLアルゴリズム単体で解の探索をするよりも高速に探索をすることができる。



\subsubsection{監視リテラル}
SAT solverの実行時間の70\%から90\%は単位伝播の処理で占められているため、効率良く単位節を検出することができればより高速に解を探索することができる。
素朴な方法として各変数$x_i$に対して$x_i$を含む節のリストを用意しておき、
$x_i$に値が割り当てられた時にそのリストを走査することで状態の変化した節を確認する方法がある。
しかしこの方法だとすでに充足されている節の確認を行う必要があり無駄が多くなってしまう。
監視リテラルを用いた方法は節の中の未割当な変数2つを監視する方法である。
節が単位節になる直前の状態は節中のリテラルのうち2つのみが未割当で残りのリテラルに偽が割り当てられている状態となっている。
どちらかのリテラルに偽が割り当てられた時に節は単位節となるため、
節中の全てのリテラルを監視する必要はなく未割当のリテラル2つのみを監視するだけで効率良く単位節を検出することができる。





\subsection{DRAT}
DRAT(Deletion Resolution Asymmetric Tautology)とは証明の表記法の1つであり、
DRUP(Deletion Reverse Unit Propagation)と呼ばれる証明の表記法を一般化したものである。
数学の問題を証明する際にいくつかの補題を組み合わせて証明をするように、
DRATの証明も主にいくつか補題を表す節を並べることで作成される。
DRATの証明の各行は、補題を表す節かそれまでにある特定の節を削除する意味を持つ削除節からなり、
最後の行は矛盾を表す長さ0の節(リテラルを1つも持たない節)となっている。
ここで証明の検証方法を説明するためにいくつか変数を取り入れる。
CNF形式の問題を$F$、CNF形式の証明を$P$として、証明が持つ節の数(証明の行数)を$|P|$とする。
$i \in \{0,1,...,|P|\}$に対して$F_{P}^{i}$を次のように定義する。
ただし、$L_i$を証明$P$における$i$行目の節とする。
\[
	F_{P}^{i} = 
	\begin{cases}
		F                           & (i=0{の場合}) \\
		F_{P}^{i-1} \setminus \{L_i\} & (L_i{が削除節の場合}) \\
		F_{P}^{i-1} \cup      \{L_i\} & ({それ以外}) 
	\end{cases}
\]
証明を検証する際には、証明の各行の節をRUPチェックとRATチェック両方で検証を行いその節を導くことができるかを検証する。
\begin{description}
	\item[RUPチェック] $F_{P}^{i-1}$に関して$L_i$を単位伝搬のみで導出することができる
		($F_{P}^{i-1} \cup \{\overline L_i\}$について単位伝搬のみで矛盾を導くことができる)
	\item[RATチェック] $F_{P}^{i-1}$に関して$L_i$が$l_i$について以下の性質を持っているか \\
		\begin{itemize}
			\item 任意の$C \in F_{P}^{i-1}$について$\overline l_i$が$C$に含まれる場合、
				$F_{P}^{i-1}$に関して$(C \setminus {\overline l_i}) \cup L_i$を単位伝搬のみで導出することができる。
		\end{itemize}
\end{description}
実際に検証するツールとしてdrat-trimが存在する。
このツールのもう1つの特徴として元の証明を短くすることができる。
検証を行う際にもとの証明の中で使用されなかった節を削除する方法で元の証明よりも短い証明を出力している。



\subsubsection{学習節とDRAT}
CDCLソルバーが作成する学習節はこのDRATの証明になっている。
先ほど述べたように、学習節は以降の探索の際に矛盾を引き起こした割当になることを防ぐ役割を持っている。
例えば学習節$C$が$l_1 \lor l_2 \lor ... \lor l_n$を形をしているとする。
この学習節が作られた際には$l_1=\bot, l_2=\bot, ... , l_n=\bot$という割当によって矛盾が引き起こされていたことがわかる
($\overline C = \overline l_1 \land \overline l_2 \land ... \land \overline l_n$)。
つまり$\overline C$を仮定した時に単位伝搬のみで矛盾を導くことができるため、RUPチェックによってこの学習節を導くことができる。
したがって、CDCLソルバーが問題を解く際に作成されていく学習節を並べていくと問題がUNSATである時のDRATの証明になっている。
この作り方において、証明の中に削除節は存在しない(後述する今回の実験で使うソルバーにおいては削除節が作成される)。



\subsubsection{証明の長さ}
実験の目標とする短い証明を作ることについて、ここでは証明の長さを証明の節の中で補題を表す節の数で表す。
削除を表す節はそれ自体が存在しなくても証明として成り立つため、削除を表す節については考慮しない。





\subsection{minisat}



SATソルバーの1つであり、今回証明を作成するのに使用しているソルバーである。

特長の1つとして詳細を理解しやすいという点がある。
既存の最先端のソルバーを改良することは、仮に問題領域やSATソルバーに関する技術を深く理解していても10000行を超えるプログラムを理解しなければならず、極めて時間のかかる作業になってしまう。
同様にゼロからソルバーを構築しようとしても多くの時間を費やす必要がある。
このように時間がかかってしまう理由としては、現代のソルバーで用いられている技術は十分に文書化されている一方で、
実装に必要な詳細が十分に提示されていないことが挙げられる。

これに対してminisatは
\begin{itemize}
	\item プログラム全体のコード行が6000行と比較的少ない
	\item 矛盾からの節学習、監視リテラル、変数への重み付けといった既存のソルバーに多く採用されている技術が使用されている
	\item 実装の詳細について説明した論文が存在する
	\item オープンソースである
\end{itemize}
ため、改造がしやすかったり独自のソルバーをゼロから構築しやすくなっている。

今回は変数選択へ介入を行うため、ソルバーの改造が必要であるという理由から、minisatを使用した。





\subsection{遺伝アルゴリズム}



遺伝アルゴリズム(G.A.: genetic algorithm)とは、John Hollandによって発明された、最適化アルゴリズムのことである。
このアルゴリズムは自然進化に見られる過程のいくつかを模倣して構築されている。
この進化は染色体と呼ばれる生物の構造を符号化するための有機的な装置上で生じており、
1個体の生物は染色体を翻訳する過程により作られる。
染色体のコード化と翻訳の過程の特徴として、
\begin{itemize}
	\item {進化は生命体そのものにではなく、それを符号化した染色体に対して操作を行う過程からなる}
	\item {自然淘汰は、染色体とそれをデコードした結果できた構造体の環境への適応度を結びつける。
	この過程により、より適応した染色体はより頻繁に再生に用いられる。}
	\item{再生と呼ばれる今ある染色体から新しい染色体を生成する操作の過程で、進化が起きると考えられる。
	突然変異と呼ばれる操作によって親のものとは異なった染色体が生成され、
	組み替えの過程を通して両者の染色体の構成物質が組み合わされてどちらの親の特徴を持つ全く異なった染色体が作られる。}
\end{itemize}
といった特徴がある。












\section{実装}





\subsubsection{証明を作る}



\begin{itemize}
	\item{前処理}
	\item{学習節の追加}
\end{itemize}





\subsubsection{変数選択への介入}





\subsubsection{遺伝アルゴリズム}



\begin{itemize}
	\item{オペレータ}
	\begin{itemize}
		\item{交叉}
		\item{突然変異}
	\end{itemize}
	\item{その他パラメータ}
\end{itemize}





\section{問い}










\section{実験}










\section{結果}










\section{考察}










\section{まとめ}










\end{document}