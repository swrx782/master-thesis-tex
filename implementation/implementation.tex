\section{実装}





実験を行うにあたっていくつかの実装を行なった。

% どういうことをしたかを書いたけどここでは不要なので一旦コメントアウト
\begin{comment}
まず最初にminisatに対しての2種類のオプションを可能にする改造を行なった。
どちらのオプションもファイル名を指定して使用するオプションである。
1つ目のオプションが使用された場合、問題を解く前にminisatは指定されたファイル名のファイルを新規で作成する。
minisatが問題を解く中で新しく節を作成した場合に指定したファイルにその節を追加したという情報を書き込み、
節を削除した場合には指定したファイルその節を削除したという情報を書き込む操作が行われるようにminisatを改造した。
2つ目のオプションが使用された場合、問題を解く前にminisatは指定されたファイルを読み込んでそこからどのような介入を行うかのデータを記憶する。
この介入は何回目の変数選択の際にどのように変数のスコアを書き換えるかという情報を表している。
そして、minisatが問題を解く中で変数選択の回数が指定した回数になった場合、指定した方法で変数のスコアを書き換えるようにminisatを改造した。

次に遺伝アルゴリズムを実行するプログラムの作成を行なった。
このプログラムはCDCLソルバーとUNSATな問題とその他遺伝アルゴリズムに必要なパラメータの情報を受け取る。
これらを受け取った後、プログラムは介入の列で表現される染色体からなる初期の集団を作成し、
そこから交叉と突然変異を用いながら、
指定した問題を指定したCDCLソルバーが解いた際に短い証明を作成できるような介入列の探索を行う。
\end{comment}

これにより
\begin{itemize}
	\item 変数選択における介入とDRATの証明ファイルの作成が可能になったminisat
	\item 変数選択の際に各変数のスコアをランダムに書き換えることとその復元が可能なCDCLソルバーとUNSATな問題を受け取って、
	      その問題の短い証明を作れるような変数選択における重みの書き換えの介入列を探索する遺伝アルゴリズム
\end{itemize}
の2つのアプリケーションを作成した

以下でこの実装を再現するための詳細な説明を行う。





\subsection{変数選択への介入}



% どういうランダム関数を使って書き換えたか
% 介入ファイルのフォーマット
% どの順番で変数を書き換えたのか




続いて、minisatの変数選択に介入を行なった。
準備の部分で述べたように、minisatは各変数にスコアを割り当てており、変数選択を行う際にこのスコアが1番高い変数を選ぶ仕組みになっている。
この変数のスコアを変更するように介入を行なった。

まず初めに介入のためのオプションを追加した。
追加した方法は証明を作る際に変更した方法と同じであり、証明を作るオプションの次にstringOption型でオプション名はinterventionとして変数interventionの宣言を行なった。
これによりオプションで"-intervention=介入ファイル名"を追加することで変数interventionに介入ファイル名を保存できるようになった。

介入の実装の前に今回使用する介入ファイルの

また、後述する遺伝アルゴリズムと組み合わせる際には一度行なった介入を再度行わなければならない可能性がある。
つまり一度書き換えた各変数のスコアを再現しなければならない。
変数のスコアを全て保存しておいて、同様の介入を再現する際に全てのスコアを読み取って書き換える方法があるが、
変数が多い場合にはサイズが莫大な大きさになってしまう。
今回はスコアを全て保存するのではなくその値を割当てる前にシード値を保存しておき、同様の介入を再現する場合には書き換える前にシード値を保存したシード値に変更してから書き換えを行なうような形で同様の介入を再現した。

したがって、minisatの変数選択に介入する際には
\begin{itemize}
	\item 介入のタイミング(何回目の変数選択で介入を行うか)
	\item ランダムで書き換えることを指定する値、または一度行なった介入を再現するためのシード値
\end{itemize}
の2つを指定することで変数選択に介入を行えるようにminisatを改造した。
複数回介入を行う際にはこの2つの値を並べることで複数回の介入を行うことができる。




% 証明を作る
\input{implementation/make-a-proof.tex}



\subsubsection{minisatのプログラムの概要}

プログラムは全てC++で書かれており、
\begin{itemize}
	\item ベクトルやランダム関数といった簡単なデータ構造や関数を定義するmtlフォルダ(Mini Template Liblary)
	\item 構文解析やオプション解析といった汎用的な操作を定義するutilsフォルダ
	\item 解の探索といったminisatの核となる操作を定義するcoreフォルダ
	\item より効率的に問題を解くために、問題を解く前に行う前処理を定義するsimpフォルダ
\end{itemize}
の4種類のフォルダから構成される。

実際に問題を解く際にはsimpフォルダの中にあるmain.ccを実行する。
最初にどのようなオプションを受け付けるか(オプション名、オプションの値をどの変数に格納するか、格納する値の型など)を定義し、
関数parseOptionsを呼び出してコマンドからどのオプションが使用されているかを解析し、変数に値を格納する。
次に、ソルバーの状態を表すSimpSolverクラスの変数Sを宣言する。
節の情報といった探索の中で必要な値は全てこのSの中の変数に保存される。
その後、関数gzopenを呼び出して問題のファイルを開き、parse\_DIMACSを呼び出して変数の数や節の数、各節の情報などを各変数に代入する。
そして、関数eliminateを呼び出すことで問題の前処理(簡約化)を行い、その時点でUNSATと判明した場合はUNSATを返し、
そうでない場合は関数solveLimitedを呼び出して問題を解く。
問題を解き終えると、SATである場合は各変数の割当とともにSATを、UNSATである場合はUNSATを出力して終了する。
これがminisatが問題を解く際のおおまかな処理の流れである。

なお関数solveLimitedを呼び出して問題を解く際のminisatのおおまかな動きは以下のようになっている。
最初に単位伝搬によって単位節がある場合に新しい変数に割当を行なっていき、矛盾が発生しなかった(同じ変数に真と偽両方の変数を割り当てなければならない状態にならなかった)場合で、
全ての変数に割当がなされた場合はSATを返す。
まだ未割当の変数がある場合には関数decideによって未割当の変数を1つ選択し、値を割り当てる。
矛盾が発生した場合には関数analyzeによって矛盾が起きた原因を探り学習節を作成する。
もし矛盾がトップレベル(1つも変数選択をしていない状態)で起きたのであればUNSATを返す。
そうでない場合はbacktrack関数によって学習節が単位節になるまで直近の変数への割当を未割当に戻していく操作を行う。
単位節になった時点で止めることで次のループの最初の単位伝搬によって新しく変数に割当をすることができる。





\subsection{遺伝アルゴリズム}



ここからは準備で述べた遺伝アルゴリズムを今回の実験においてどのように実装を行うかについて説明する。

まず最初に考えるべき部分として染色体をどのように表現するかという部分と評価関数をどのように定義するかという部分がある。
今回はタイミングと書き換え方法を表す値を1つの組にしたものを1つの介入として、この介入を並べた介入列を染色体とした。
この時介入のタイミングの上限は、介入なしで解かせた時の変数選択数とした。
また、評価関数については染色体(介入列)を受け取ってその介入のもとでminisatを実行してからdrat-trimを実行した後にできる証明の長さを返す関数とした。

続いて新しい子を作成する際に用いる交叉と突然変異のオペレータについて考える。
交叉については、2つの親に対してある1点を指定してそれ以降を交換する1点交叉を使用した。
具体的にはタイミングをランダムに指定して、そのタイミング以降の介入列を交換するようにした。
突然変異については、新しい介入を1つ追加する突然変異と今ある介入の中から1つ削除する突然変異の2つを採用した。

その他細かい部分として新しい子を生成する際の親の選択方法としては、各染色体の評価値の逆数を重みとしてランダムに選択している。
つまり短い証明を作成するような染色体ほど親として選ばれやすいようになっている。
また新しい世代の作り方としては既存の集団の一部分を削除して空いた部分に新しく生成した子を入れて作るのではなく、
既存の集団を全て削除して新しく生成した子で全て入れ替えるようにしている。

実装における細かい部分としては、遺伝アルゴリズムの実行後の結果ファイルの作成時に調整を行なった。
遺伝アルゴリズム実行後のデータとして、各世代各染色体の証明の長さをリストにしたデータと各世代各染色体の介入列などの全情報も含めたデータを作成しているが、
後者のデータに関しては染色体の介入列の長さが大きくなった際に全体のデータ量が大きくなってしまう問題がある。
この問題を解消するために各世代各染色体の情報をデータに収めるのではなく、その染色体を作るためにどのような交叉をしたかやどのような突然変異をしたかなどの復元のための情報をデータに収めるようにした。
復元の際に時間がかかるものの、全染色体の介入列の情報など全ての情報を復元によって手に入れることができる。
加えて交叉や突然変異の方法が大きく変わらない(復元のための情報が大きくならない)限り、染色体の介入数がどれだけ大きくなっても一定サイズのデータで出力することができる。