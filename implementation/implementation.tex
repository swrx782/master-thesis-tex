\section{実装}





実験を行うにあたっていくつかの実装を行なった。

% どういうことをしたかを書いたけどここでは不要なので一旦コメントアウト
\begin{comment}
まず最初にminisatに対しての2種類のオプションを可能にする改造を行なった。
どちらのオプションもファイル名を指定して使用するオプションである。
1つ目のオプションが使用された場合、問題を解く前にminisatは指定されたファイル名のファイルを新規で作成する。
minisatが問題を解く中で新しく節を作成した場合に指定したファイルにその節を追加したという情報を書き込み、
節を削除した場合には指定したファイルその節を削除したという情報を書き込む操作が行われるようにminisatを改造した。
2つ目のオプションが使用された場合、問題を解く前にminisatは指定されたファイルを読み込んでそこからどのような介入を行うかのデータを記憶する。
この介入は何回目の変数選択の際にどのように変数のスコアを書き換えるかという情報を表している。
そして、minisatが問題を解く中で変数選択の回数が指定した回数になった場合、指定した方法で変数のスコアを書き換えるようにminisatを改造した。

次に遺伝アルゴリズムを実行するプログラムの作成を行なった。
このプログラムはCDCLソルバーとUNSATな問題とその他遺伝アルゴリズムに必要なパラメータの情報を受け取る。
これらを受け取った後、プログラムは介入の列で表現される染色体からなる初期の集団を作成し、
そこから交叉と突然変異を用いながら、
指定した問題を指定したCDCLソルバーが解いた際に短い証明を作成できるような介入列の探索を行う。
\end{comment}

これにより
\begin{itemize}
	\item 変数選択における介入とDRATの証明ファイルの作成が可能になったminisat
	\item 変数選択の際に各変数のスコアをランダムに書き換えることとその復元が可能なCDCLソルバーとUNSATな問題を受け取って、
	      その問題の短い証明を作れるような変数選択における重みの書き換えの介入列を探索する遺伝アルゴリズム
\end{itemize}
の2つのアプリケーションを作成した

以下でこの実装を再現するための詳細な説明を行う。





% 変数選択への介入
\input{implementation/intervention.tex}





% 証明を作る
\input{implementation/make-a-proof.tex}



\subsubsection{minisatのプログラムの概要}

プログラムは全てC++で書かれており、
\begin{itemize}
	\item ベクトルやランダム関数といった簡単なデータ構造や関数を定義するmtlフォルダ(Mini Template Liblary)
	\item 構文解析やオプション解析といった汎用的な操作を定義するutilsフォルダ
	\item 解の探索といったminisatの核となる操作を定義するcoreフォルダ
	\item より効率的に問題を解くために、問題を解く前に行う前処理を定義するsimpフォルダ
\end{itemize}
の4種類のフォルダから構成される。

実際に問題を解く際にはsimpフォルダの中にあるmain.ccを実行する。
最初にどのようなオプションを受け付けるか(オプション名、オプションの値をどの変数に格納するか、格納する値の型など)を定義し、
関数parseOptionsを呼び出してコマンドからどのオプションが使用されているかを解析し、変数に値を格納する。
次に、ソルバーの状態を表すSimpSolverクラスの変数Sを宣言する。
節の情報といった探索の中で必要な値は全てこのSの中の変数に保存される。
その後、関数gzopenを呼び出して問題のファイルを開き、parse\_DIMACSを呼び出して変数の数や節の数、各節の情報などを各変数に代入する。
そして、関数eliminateを呼び出すことで問題の前処理(簡約化)を行い、その時点でUNSATと判明した場合はUNSATを返し、
そうでない場合は関数solveLimitedを呼び出して問題を解く。
問題を解き終えると、SATである場合は各変数の割当とともにSATを、UNSATである場合はUNSATを出力して終了する。
これがminisatが問題を解く際のおおまかな処理の流れである。

なお関数solveLimitedを呼び出して問題を解く際のminisatのおおまかな動きは以下のようになっている。
最初に単位伝搬によって単位節がある場合に新しい変数に割当を行なっていき、矛盾が発生しなかった(同じ変数に真と偽両方の変数を割り当てなければならない状態にならなかった)場合で、
全ての変数に割当がなされた場合はSATを返す。
まだ未割当の変数がある場合には関数decideによって未割当の変数を1つ選択し、値を割り当てる。
矛盾が発生した場合には関数analyzeによって矛盾が起きた原因を探り学習節を作成する。
もし矛盾がトップレベル(1つも変数選択をしていない状態)で起きたのであればUNSATを返す。
そうでない場合はbacktrack関数によって学習節が単位節になるまで直近の変数への割当を未割当に戻していく操作を行う。
単位節になった時点で止めることで次のループの最初の単位伝搬によって新しく変数に割当をすることができる。





% 遺伝アルゴリズム
\input{implementation/genetic-algorithm.tex}