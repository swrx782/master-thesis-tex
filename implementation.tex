\section{実装}





実験を行うにあたっていくつかの実装を行なった。

% どういうことをしたかを書いたけどここでは不要なので一旦コメントアウト
\begin{comment}
まず最初にminisatに対しての2種類のオプションを可能にする改造を行なった。
どちらのオプションもファイル名を指定して使用するオプションである。
1つ目のオプションが使用された場合、問題を解く前にminisatは指定されたファイル名のファイルを新規で作成する。
minisatが問題を解く中で新しく節を作成した場合に指定したファイルにその節を追加したという情報を書き込み、
節を削除した場合には指定したファイルその節を削除したという情報を書き込む操作が行われるようにminisatを改造した。
2つ目のオプションが使用された場合、問題を解く前にminisatは指定されたファイルを読み込んでそこからどのような介入を行うかのデータを記憶する。
この介入は何回目の変数選択の際にどのように変数のスコアを書き換えるかという情報を表している。
そして、minisatが問題を解く中で変数選択の回数が指定した回数になった場合、指定した方法で変数のスコアを書き換えるようにminisatを改造した。

次に遺伝アルゴリズムを実行するプログラムの作成を行なった。
このプログラムはCDCLソルバーとUNSATな問題とその他遺伝アルゴリズムに必要なパラメータの情報を受け取る。
これらを受け取った後、プログラムは介入の列で表現される染色体からなる初期の集団を作成し、
そこから交叉と突然変異を用いながら、
指定した問題を指定したCDCLソルバーが解いた際に短い証明を作成できるような介入列の探索を行う。
\end{comment}

これにより
\begin{itemize}
	\item 変数選択における介入とDRATの証明ファイルの作成が可能になったminisat
	\item 変数選択の際に各変数のスコアをランダムに書き換えることとその復元が可能なCDCLソルバーとUNSATな問題を受け取って、
	      その問題の短い証明を作れるような変数選択における重みの書き換えの介入列を探索する遺伝アルゴリズム
\end{itemize}
の2つのアプリケーションを作成した

以下でこの実装を再現するための詳細な説明を行う。





\subsection{変数選択への介入}



% どういうランダム関数を使って書き換えたか
% 介入ファイルのフォーマット
% どの順番で変数を書き換えたのか




続いて、minisatの変数選択に介入を行なった。
準備の部分で述べたように、minisatは各変数にスコアを割り当てており、変数選択を行う際にこのスコアが1番高い変数を選ぶ仕組みになっている。
この変数のスコアを変更するように介入を行なった。

まず初めに介入のためのオプションを追加した。
追加した方法は証明を作る際に変更した方法と同じであり、証明を作るオプションの次にstringOption型でオプション名はinterventionとして変数interventionの宣言を行なった。
これによりオプションで"-intervention=介入ファイル名"を追加することで変数interventionに介入ファイル名を保存できるようになった。

介入の実装の前に今回使用する介入ファイルの

また、後述する遺伝アルゴリズムと組み合わせる際には一度行なった介入を再度行わなければならない可能性がある。
つまり一度書き換えた各変数のスコアを再現しなければならない。
変数のスコアを全て保存しておいて、同様の介入を再現する際に全てのスコアを読み取って書き換える方法があるが、
変数が多い場合にはサイズが莫大な大きさになってしまう。
今回はスコアを全て保存するのではなくその値を割当てる前にシード値を保存しておき、同様の介入を再現する場合には書き換える前にシード値を保存したシード値に変更してから書き換えを行なうような形で同様の介入を再現した。

したがって、minisatの変数選択に介入する際には
\begin{itemize}
	\item 介入のタイミング(何回目の変数選択で介入を行うか)
	\item ランダムで書き換えることを指定する値、または一度行なった介入を再現するためのシード値
\end{itemize}
の2つを指定することで変数選択に介入を行えるようにminisatを改造した。
複数回介入を行う際にはこの2つの値を並べることで複数回の介入を行うことができる。





\subsection{証明を作る}



% どういう関数に手を加えたのか



今回の研究においては証明が必要不可欠であり、使用したいソルバーが証明を作成しない場合、そのままの状態では実験に使用することができない。
minisatには証明を出力してファイルに保存する機能が存在しなかったので既存のminisatを改造することで証明を出力できるようにした。

ソルバーが新しく節の追加や削除を行なっている関数についてその際に証明ファイルに節を追加するように変更を行なった。
この節の追加や削除を行なっている関数は2種類に分類することができる。
それは学習節を作る関数と前処理を行う関数の2種類である。
上述したようにこの証明を出力させる方法としてCDCLソルバーが作成する学習節を順にファイルに追加していくことで証明を作ることができるのだが、
minisatにはこの学習節以外にも新しく節を作成している部分が存在するためこのままでは証明として成立してない。
minisatは問題の解を探索する前に、より効率的に探索をするために前処理という操作を行なっている。
この前処理の段階でminisatは問題にあるいくつかの節を組み合わせたりしながら新しい節を作成している。
そのため、この新しく作成した節も証明の中の節として出力する必要がある。
この2種類の方法で作成される節や削除される節を出力していくことで証明ファイルを作成できるように実装を行なった。
なお、証明ファイルポインタは変数proof\_fileに格納されており、節を出力する際には1番目のリテラルから順に出力している。

まず新しく学習節を作る部分についてだが、minisatが学習節を作っているのはsimp/solver.ccの中の関数searchの中にある関数analyzeの部分である。
関数analyzeは矛盾が起きた節と学習節を入れる変数learnt\_clauseとどのレベルまでバックトラックすべきかを表す変数を受け取り、矛盾の原因を探る。
さらにこの関数は同時にその矛盾から学習節を作成しlearnt\_clauseに代入するため、この変数の情報を証明のファイルに出力した。
関数analyzeの後の関数cancelUntilが終了した後にfor文を用いて変数learnt\_clauseの1番目のリテラルの情報から最後のリテラルの情報まで出力を行なった。
\begin{lstlisting}[caption=関数analyzeの変更(core/solver.cc), firstnumber=296]
	// CONFLICT
	// 矛盾の発生
    conflicts++; conflictC++;
    if (decisionLevel() == 0) return l_False;

	// 学習節の作成
    learnt_clause.clear();
    analyze(confl, learnt_clause, backtrack_level);
    cancelUntil(backtrack_level);
    
	// 追記部分
	// 作った学習節をファイルに出力
    if (proof_file) {
        for (int j = 0; j < learnt_clause.size(); j++) {
			fprintf(proof_file, "%s%d ", (sign(learnt_clause[j])? "-" : ""), var(learnt_clause[j])+1); 
        }
        fprintf(proof_file, "0\n");
    }

	// 学習節をデータベースに追加(節の長さが1である場合は次の単位伝搬のためのキューに追加)
	if (learnt_clause.size() == 1){
        uncheckedEnqueue(learnt_clause[0]);
    }else{
        CRef cr = ca.alloc(learnt_clause, true);
        learnts.push(cr);
        attachClause(cr);
        claBumpActivity(ca[cr]);
        uncheckedEnqueue(learnt_clause[0], cr);
    }
\end{lstlisting}

次に前処理における新規の節追加と節削除について説明する。

% 注意点(正しいDRATかどうかの確認はしていないこと)
注意点として、今回おこなった実装は必ず証明として成り立つことを保証していない。
前処理における全ての操作を理解し、要所要所の処理をDRATとしてどのように出力すべきかという確認が、
正しく節が作られているかどうかを保証するために必要である。
しかし、前処理に含まれる操作は複雑なものとなっており、その操作全てについて理解ができていない。
今回はほとんど内容を無視するかたちで、前処理が節を作成・削除していると思われている箇所でその節を証明ファイルに追加節・削除節として出力した。
そのためこれで必要な節が足りているかどうかや不要な節を追加しているかどうかはわからない。
実装をおこなってから現時点までの研究において証明を検証するdrat-trimが検証に失敗したという旨のエラー出力は確認されていない。

% minisatの3つの処理
前述したように前処理での全体の動きは複雑なものになっているが、
節に関連する処理としてここではminisatは節を追加する処理と、節を削除する処理と、節の形を変更する処理をおこなっている。

% 1つ目の処理(節を追加する処理)
1つ目の節を追加する処理についてはcore/solver.ccの中の関数addClause\_()の中で行われている。
この関数は追加したい節を受け取ってその節が可能なら節の縮小を行い、その後節を追加したり、
節の長さ(節に含まれる変数の個数)が1である場合は追加せずに変数への割当を行うよう指示を出す。
ここでは節の縮小を行う前に節を証明のファイルに出力し、さらに節の縮小を行なった直後にも節を証明のファイルに出力した。

\begin{lstlisting}[caption=関数addClause\_の変更(core/solver.cc), firstnumber=154]
    bool Solver::addClause_(vec<Lit>& ps)
    {
        assert(decisionLevel() == 0);
        if (!ok) return false;

        // 追記開始
        // 証明部分
        if (proof_file){
            for (int k=0; k<ps.size(); k++){
                fprintf(proof_file, "%s%d ", (sign(ps[k])? "-" : ""), var(ps[k])+1);
            }
            fprintf(proof_file, "0\n");
        }
        // 追記終了

        // 節の縮小
        // Check if clause is satisfied and remove false/duplicate literals:
        sort(ps);
        Lit p; int i, j;
        for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
            if (value(ps[i]) == l_True || ps[i] == ~p)
                return true;
            else if (value(ps[i]) != l_False && ps[i] != p)
                ps[j++] = p = ps[i];
        ps.shrink(i - j);

        // 追記開始
        // 証明部分
        if (proof_file){
            for (int k=0; k<ps.size(); k++){
                fprintf(proof_file, "%s%d ", (sign(ps[k])? "-" : ""), var(ps[k])+1);
            }
            fprintf(proof_file, "0\n");
        }
        // 追記終了

        // 節の追加(節の長さが1である場合は次の単位伝搬のためのキューに追加)
        if (ps.size() == 0)
            return ok = false;
        else if (ps.size() == 1){
            uncheckedEnqueue(ps[0]);
            return ok = (propagate() == CRef_Undef);
        }else{
            CRef cr = ca.alloc(ps, false);
            clauses.push(cr);
            attachClause(cr);
        }

        return true;
    }
\end{lstlisting}

% 2つ目の節を削除する処理
2つ目の節を削除する処理についてはcore/solver.ccの中の関数removeClauseとcore/solver.ccの中の関数removeSatisfiedで行われている。
前者についてはremoveClauseの処理の最初に削除節を証明のファイルに出力した。
\begin{lstlisting}[caption=関数addClause\_の変更(core/solver.cc), firstnumber=212]
    void Solver::removeClause(CRef cr) {
        // 追記開始
        // 証明部分
        if (proof_file) {
            fprintf(proof_file, "d ");
            for (int k = 0; k < ca[cr].size(); k++) {
                fprintf(proof_file, "%s%d ", (sign(ca[cr][k])? "-" : ""), var(ca[cr][k])+1);
            }
            fprintf(proof_file, "0\n");
        }
        // 追記終了
        Clause& c = ca[cr];
        detachClause(cr);
        // Don't leave pointers to free'd memory!
        if (locked(c)) vardata[var(c[0])].reason = CRef_Undef;
        c.mark(1); 
        ca.free(cr);
    }
\end{lstlisting}
後者の関数は全ての節に対して、現在の変数割当において既に満足している節を削除する際に使用される関数である。
この関数は節中の既に偽なリテラルに関してはそのリテラルを削除することで節の長さを縮小する役割も担っている。
ここでの変更として、節の縮小がなされた場合は縮小後の節を追加しつつ縮小前の節を削除し、
節の縮小がなされていない場合は受け取った節を追加する情報を証明ファイルに出力するように変更を行なった。
関数の実行を行う前に文字列型の変数pre\_clauseとブール型の変数changedを定義し、
各節に対して縮小を行う前にその節を削除する場合に証明ファイルに出力される文字列をpre\_clauseに保存し、changedにはFalseを代入した。
節の縮小が1度でもなされた場合にchangedにTrueを代入し、節の縮小の確認が終わったあとに現在の節を証明ファイルに出力するが、
changedの値がTrueである場合には縮小前の節を削除するようにpre\_clauseも証明ファイルに出力するように変更した。
なお受け取った節が現在の割当において真になっている場合は節を削除するが、関数removeClauseを呼び出しているため、
ここでの節の削除の出力はremoveClauseの中で行う。
\begin{lstlisting}[caption=関数removeSatisfiedの変更(core/solver.cc), firstnumber=601]
    void Solver::removeSatisfied(vec<CRef>& cs)
    {
        int i, j;
        // 追記開始
        string pre_clause;  // 節を縮小する前の節を表す文字列
        bool changed;       // 節の変更(縮小)がされたかどうか
        // 追記終了
        for (i = j = 0; i < cs.size(); i++){
            Clause& c = ca[cs[i]];
            // 追記開始
            // 縮小前の節を表す文字列をpre\_clauseに保存
            if (proof_file) {
                pre_clause = "d ";
                changed = false;
                for (int l = 0; l < ca[cs[i]].size(); l++) {
                    pre_clause += (sign(ca[cs[i]][l])? "-" : "") + to_string(var(ca[cs[i]][l])+1) + " ";
                }
                pre_clause = pre_clause + "0";
            }
            // 追記終了
            if (satisfied(c))
                removeClause(cs[i]);
            else{
                // Trim clause:
                assert(value(c[0]) == l_Undef && value(c[1]) == l_Undef);
                for (int k = 2; k < c.size(); k++)
                    if (value(c[k]) == l_False){
                        c[k--] = c[c.size()-1];
                        c.pop();
                        changed = true; // 追記
                    }
                cs[j++] = cs[i];
                // 追記開始
                // 証明部分
                if (proof_file) {
                    // 現在の節(ca[cs[i]])を追加
                    for (int l = 0; l < ca[cs[i]].size(); l++) {
                        fprintf(proof_file, "%s%d ", (sign(ca[cs[i]][l])? "-" : ""), var(ca[cs[i]][l])+1);
                    }
                    fprintf(proof_file, "0\n");
                    // 節が変わっている場合は変更前の節を削除
                    if (changed) fprintf(proof_file, "%s\n", pre_clause.c_str());
                }
                // 追記終了
            }
        }
        cs.shrink(i - j);
    }
\end{lstlisting}

% 3つ目の節を変更する処理
3つ目の処理を行なっているのはsimp/SimpSolver.ccの中の関数strengthenClauseである。
後者の関数は節と節に含まれるリテラルを受け取ってその節からリテラルを削除する関数になっている。
ここではreturn文によって関数を抜ける前に新しくできた節を証明ファイルに追加するように変更した。
関数内では受け取った節の長さに応じてif文を使って分岐処理を行なっているが、どちらの場合でも変更後の節を証明ファイルに出力している。
\begin{lstlisting}[caption=関数strengthenClauseの変更(simp/SimpSolver.cc), firstnumber=203]
    bool SimpSolver::strengthenClause(CRef cr, Lit l)
    {
        Clause& c = ca[cr];
        assert(decisionLevel() == 0);
        assert(use_simplification);

        // FIX: this is too inefficient but would be nice to have (properly implemented)
        // if (!find(subsumption_queue, &c))
        subsumption_queue.insert(cr);

        if (c.size() == 2){
            removeClause(cr);
            c.strengthen(l);
        }else{
            detachClause(cr, true);
            c.strengthen(l);
            attachClause(cr);
            remove(occurs[var(l)], cr);
            n_occ[l]--;
            updateElimHeap(var(l));
        }

        // 追記開始
        // 証明部分
        if (proof_file) {
            for (int k = 0; k < ca[cr].size(); k++) {
                fprintf(proof_file, "%s%d ", (sign(ca[cr][k])? "-" : ""), var(ca[cr][k])+1);
            }
            fprintf(proof_file, "0\n");
        }
        // 追記終了

        return c.size() == 1 ? enqueue(c[0]) && propagate() == CRef_Undef : true;
    }
\end{lstlisting}

% オプションの追加
上記の処理をオプションとして証明を作成する旨のオプション名を受け付けるようにプログラムの変更を行なった。

% 変数の定義
まずminisatで定義されているオプションのクラスを使用してオプションの定義を行なった。
minisatにおけるオプションはutil/Options.hにおいてクラスOptionの定義を行い、
そのクラスを継承しブール数型のオプションクラスBoolOptionや文字列型のオプションクラスStringOptionを定義している。
既存のオプションはsimp/main.ccの最初の方に
カテゴリー, オプション名, オプションの詳細, (整数型などの場合は範囲も)を指定して各型のオプションクラスの変数を
宣言をすることで実際にそのオプションが使用された場合にその型に適した値を変数に格納しておき後で参照することができる。
今回は証明を出力するファイル名を保存しておくために、オプション名をproofで指定して文字列型オプションの変数proofを既存のオプションと同じ位置に宣言した。
これによりコマンドに"-proof=証明ファイル名"を加えることで証明ファイル名を変数proofに保存することができる。

% 証明ファイルポインタの作成
続いて探索の中でこの証明ファイルを使用するために、SimpSolverクラスの変数Sが持つ変数proof\_fileに証明ファイルの情報を入力する。
この変数proof\_fileにはfopen(proof, "wb")の返り値が代入され、オプションが指定されなかった場合はNULLが代入される。
この変数S.proof\_fileを使用して、問題を受け取った後にソルバーが新規で作成した節や新規で削除した節がある場合は節を証明ファイルに関数printfを使用して出力していく。
削除した節の場合は最初に"d "を出力する。
minisatの節は各要素がリテラルの情報を持つリストになっており、節を出力する際には1番目の要素から順に変数の番号を出力して空白を1文字出力する。
リテラルが変数の否定の形をしている場合は番号の前に"-"をつけて出力する。
この証明ファイルは問題がSATや途中終了であった場合も削除せず残る。
この場合、証明ファイルの中身はプログラムが終了するまでにminisatが出力した補題を表す節の列になっている。
\begin{lstlisting}[caption=オプションを定義するための関数mainの変更(simp/Main.cc), firstnumber=60]
    // Extra options:
    //
    IntOption    verb   ("MAIN", "verb",   "Verbosity level (0=silent, 1=some, 2=more).", 1, IntRange(0, 2));
    BoolOption   pre    ("MAIN", "pre",    "Completely turn on/off any preprocessing.", true);
    BoolOption   solve  ("MAIN", "solve",  "Completely turn on/off solving after preprocessing.", true);
    StringOption dimacs ("MAIN", "dimacs", "If given, stop after preprocessing and write the result to this file.");
    IntOption    cpu_lim("MAIN", "cpu-lim","Limit on CPU time allowed in seconds.\n", 0, IntRange(0, INT32_MAX));
    IntOption    mem_lim("MAIN", "mem-lim","Limit on memory usage in megabytes.\n", 0, IntRange(0, INT32_MAX));
    BoolOption   strictp("MAIN", "strict", "Validate DIMACS header during parsing.", false);

    // 追記開始
    // 証明を吐かせるかどうかのオプション
    StringOption proof          ("MAIN", "proof", "If given, write the proof to this file(proof=column of lemmas).");
    // 追記終了

    parseOptions(argc, argv, true);
        
    SimpSolver  S;
    double      initial_time = cpuTime();

    if (!pre) S.eliminate(true);

    S.verbosity = verb;

    S.proof_file = (proof)? fopen(proof, "wb") : NULL; // 証明ファイルのポインタをメンバ変数に保存 // 追記箇所
        
    solver = &S;
    // Use signal handlers that forcibly quit until the solver will be able to respond to
    // interrupts:
    sigTerm(SIGINT_exit);
\end{lstlisting}
また、新しくメンバ変数proof\_fileを追加するためにクラスの定義部分にメンバ変数を追加している。
この変数は初期値としてNULLが代入されている。
\begin{lstlisting}[caption=メンバ変数の追加(core/Solver.h), firstnumber=120]
    // Extra results: (read-only member variable)
    //
    vec<lbool> model;             // If problem is satisfiable, this vector contains the model (if any).
    LSet       conflict;          // If problem is unsatisfiable (possibly under assumptions),
                                  // this vector represent the final conflict clause expressed in the assumptions.

    // Mode of operation:
    //
    int       verbosity;
    FILE*     proof_file; // 証明ファイルのポインタ // 追加箇所
    double    var_decay;
    double    clause_decay;
\end{lstlisting}
\begin{lstlisting}[caption=メンバ変数の初期化(core/Solver.cc), firstnumber=54]
    Solver::Solver() :

    // Parameters (user settable):
    //
    verbosity        (0)
  , proof_file       (NULL) // 証明ファイルポインタの初期値 // 追加箇所
  , var_decay        (opt_var_decay)
  , clause_decay     (opt_clause_decay)
\end{lstlisting}








\subsubsection{minisatのプログラムの概要}

プログラムは全てC++で書かれており、
\begin{itemize}
	\item ベクトルやランダム関数といった簡単なデータ構造や関数を定義するmtlフォルダ(Mini Template Liblary)
	\item 構文解析やオプション解析といった汎用的な操作を定義するutilsフォルダ
	\item 解の探索といったminisatの核となる操作を定義するcoreフォルダ
	\item より効率的に問題を解くために、問題を解く前に行う前処理を定義するsimpフォルダ
\end{itemize}
の4種類のフォルダから構成される。

実際に問題を解く際にはsimpフォルダの中にあるmain.ccを実行する。
最初にどのようなオプションを受け付けるか(オプション名、オプションの値をどの変数に格納するか、格納する値の型など)を定義し、
関数parseOptionsを呼び出してコマンドからどのオプションが使用されているかを解析し、変数に値を格納する。
次に、ソルバーの状態を表すSimpSolverクラスの変数Sを宣言する。
節の情報といった探索の中で必要な値は全てこのSの中の変数に保存される。
その後、関数gzopenを呼び出して問題のファイルを開き、parse\_DIMACSを呼び出して変数の数や節の数、各節の情報などを各変数に代入する。
そして、関数eliminateを呼び出すことで問題の前処理(簡約化)を行い、その時点でUNSATと判明した場合はUNSATを返し、
そうでない場合は関数solveLimitedを呼び出して問題を解く。
問題を解き終えると、SATである場合は各変数の割当とともにSATを、UNSATである場合はUNSATを出力して終了する。
これがminisatが問題を解く際のおおまかな処理の流れである。

なお関数solveLimitedを呼び出して問題を解く際のminisatのおおまかな動きは以下のようになっている。
最初に単位伝搬によって単位節がある場合に新しい変数に割当を行なっていき、矛盾が発生しなかった(同じ変数に真と偽両方の変数を割り当てなければならない状態にならなかった)場合で、
全ての変数に割当がなされた場合はSATを返す。
まだ未割当の変数がある場合には関数decideによって未割当の変数を1つ選択し、値を割り当てる。
矛盾が発生した場合には関数analyzeによって矛盾が起きた原因を探り学習節を作成する。
もし矛盾がトップレベル(1つも変数選択をしていない状態)で起きたのであればUNSATを返す。
そうでない場合はbacktrack関数によって学習節が単位節になるまで直近の変数への割当を未割当に戻していく操作を行う。
単位節になった時点で止めることで次のループの最初の単位伝搬によって新しく変数に割当をすることができる。





\subsection{遺伝アルゴリズム}



ここからは準備で述べた遺伝アルゴリズムを今回の実験においてどのように実装を行うかについて説明する。

まず最初に考えるべき部分として染色体をどのように表現するかという部分と評価関数をどのように定義するかという部分がある。
今回はタイミングと書き換え方法を表す値を1つの組にしたものを1つの介入として、この介入を並べた介入列を染色体とした。
この時介入のタイミングの上限は、介入なしで解かせた時の変数選択数とした。
また、評価関数については染色体(介入列)を受け取ってその介入のもとでminisatを実行してからdrat-trimを実行した後にできる証明の長さを返す関数とした。

続いて新しい子を作成する際に用いる交叉と突然変異のオペレータについて考える。
交叉については、2つの親に対してある1点を指定してそれ以降を交換する1点交叉を使用した。
具体的にはタイミングをランダムに指定して、そのタイミング以降の介入列を交換するようにした。
突然変異については、新しい介入を1つ追加する突然変異と今ある介入の中から1つ削除する突然変異の2つを採用した。

その他細かい部分として新しい子を生成する際の親の選択方法としては、各染色体の評価値の逆数を重みとしてランダムに選択している。
つまり短い証明を作成するような染色体ほど親として選ばれやすいようになっている。
また新しい世代の作り方としては既存の集団の一部分を削除して空いた部分に新しく生成した子を入れて作るのではなく、
既存の集団を全て削除して新しく生成した子で全て入れ替えるようにしている。

実装における細かい部分としては、遺伝アルゴリズムの実行後の結果ファイルの作成時に調整を行なった。
遺伝アルゴリズム実行後のデータとして、各世代各染色体の証明の長さをリストにしたデータと各世代各染色体の介入列などの全情報も含めたデータを作成しているが、
後者のデータに関しては染色体の介入列の長さが大きくなった際に全体のデータ量が大きくなってしまう問題がある。
この問題を解消するために各世代各染色体の情報をデータに収めるのではなく、その染色体を作るためにどのような交叉をしたかやどのような突然変異をしたかなどの復元のための情報をデータに収めるようにした。
復元の際に時間がかかるものの、全染色体の介入列の情報など全ての情報を復元によって手に入れることができる。
加えて交叉や突然変異の方法が大きく変わらない(復元のための情報が大きくならない)限り、染色体の介入数がどれだけ大きくなっても一定サイズのデータで出力することができる。